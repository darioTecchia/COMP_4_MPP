package dist;

import java_cup.runtime.*;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.util.LinkedList;

import syntax.*;
import syntax.expr.*;
import syntax.type.*;
import syntax.statement.*;
import syntax.expr.unaryexpr.*;
import syntax.expr.binaryexpr.arithop.*;
import syntax.expr.binaryexpr.relop.*;

class Parser;

parser code{:  

public void report_error(String msg, Object info) {
  Symbol sym = (Symbol)info;
  System.out.println(msg + ": " + symbl_name_from_id(sym.sym));
}

:}

/* Terminals (tokens returned by the scanner). */
terminal String FUNCTION, MAIN, END, IF, THEN, ELSE, WHILE, DO, FOR, LOCAL, GLOBAL, READ, WRITE, RETURN, NOT, SHARP, ID;
terminal String NIL, INT, BOOL, FLOAT, STRING;
terminal String LPAR, RPAR, BLPAR, BRPAR, SLPAR, SRPAR, COMMA, SEMI, COLON;
terminal String AND, OR, LT, LE, EQ, NE, GT, GE, ARROW, ASSIGN, NOP;
terminal String PLUS, MINUS, TIMES, DIV;
terminal String UMINUS;

terminal Integer  INT_CONST;
terminal Double   FLOAT_CONST;
terminal String   STRING_CONST;
terminal Boolean  TRUE, FALSE;

/* Non Terminals */
non terminal Program Program;
non terminal Global Global;
non terminal LinkedList<Function> Functions;
non terminal Function Def_fun;
non terminal LinkedList<ParDecl> Par_decls;
non terminal LinkedList<VarDecl> Var_decls;
non terminal VarInitValue Var_init_value;
non terminal Type Type;
non terminal LinkedList<Type> Types;
non terminal LinkedList<Statement> Statements;
non terminal Statement Stat;
non terminal LinkedList<Id> Vars;
non terminal LinkedList<Expr> Exprs;
non terminal Expr Expr;

/* Precendeces */
precedence left PLUS, MINUS, OR;
precedence left TIMES, DIV, AND;
precedence nonassoc LT, LE, EQ, NE, GT, GE;
precedence left UMINUS, NOT, COMMA, SHARP;

/* The grammar */
Program ::= Global:g Functions:fs
            {:
              new Program(fsleft, fsright, g, fs);
            :}
;

Global ::= GLOBAL:g Var_decls:vs END
          {: 
            new Global(gleft, gright, vs);
          :}
          | 
          /* empty */
          {: 

          :}
;

Functions ::= Def_fun:df Functions:fs
              {: 
                fs.addFirst(df); 
                RESULT = fs;
              :}
              |
              Def_fun:df
              {: 
                RESULT = new LinkedList<Function>();
                RESULT.addFirst(df); 
              :}
;

Def_fun ::= FUNCTION:f ID:fName LPAR Par_decls:parDecls RPAR COLON Type:t Statements:stms END
            {: 
              RESULT = new Function(fleft, fright, new Id(fNameleft, fNameright, fName), parDecls, t, stms);
            :}
            |
            FUNCTION:f ID:fName LPAR RPAR COLON Type:t Statements:stms END
            {: 
              RESULT = new Function(fleft, fright, new Id(fNameleft, fNameright, fName), t, stms); 
            :}
;

Par_decls ::= ID:id COLON Type:t COMMA Par_decls:ps
              {: 
                ps.addFirst(new ParDecl(idleft, idright, new Id(idleft, idright, id), t));
                RESULT = ps;
              :}
              |
              ID:id COLON Type:t
              {: 
                RESULT = new LinkedList<ParDecl>();
                RESULT.addFirst(new ParDecl(idleft, idright, new Id(idleft, idright, id), t));
              :}
;

Var_decls ::= ID:id COLON Type:t Var_init_value:varInit SEMI Var_decls:vs
              {: 
                vs.addFirst(new VarDecl(idleft, idright, new Id(idleft, idright, id), t, varInit));
                RESULT = vs;
              :}
              |
              ID:id COLON Type:t Var_init_value:varInit
              {: 
                RESULT = new LinkedList<VarDecl>();
                RESULT.addFirst(new VarDecl(idleft, idright, new Id(idleft, idright, id), t, varInit));
              :}
;

Var_init_value ::= ASSIGN Expr:expr
                  {:
                    RESULT = new VarInitValue(exprleft, exprright, expr); 
                  :}
                  | /* empty */
                  {: 
                    RESULT = null;
                  :}
;

Type ::= NIL:nil
        {: RESULT = new PrimitiveType(nilleft, nilright, "NIL"); :}
        | 
        INT:integer
        {: RESULT = new PrimitiveType(integerleft, integerright, "INT"); :}
        | 
        BOOL:booleaner
        {: RESULT = new PrimitiveType(booleanerleft, booleanerright, "BOOL"); :}
        | 
        FLOAT:floater
        {: RESULT = new PrimitiveType(floaterleft, floaterright, "FLOAT"); :}
        | 
        STRING:stringer
        {: RESULT = new PrimitiveType(stringerleft, stringerright, "STRING"); :}
        |
        BLPAR:b Type:t BRPAR
        {: RESULT = new ArrayType(bleft, bright, t); :}
        |
        LPAR:l Types:ts RPAR ARROW Type:t
        {: RESULT = new FunctionType(lleft, lright, ts, t); :}
        |
        LPAR:l RPAR ARROW Type:t
        {: RESULT = new FunctionType(lleft, lright, t); :}
;

Types ::= Type COMMA Types
  | Type
;

Statements ::= Stat SEMI Statements
  | Stat
;

Stat ::= NOP
  | WHILE Expr DO Statements END
  | IF Expr THEN Statements END
  | IF Expr THEN Statements ELSE Statements END
  | FOR ID ASSIGN Expr COMMA Expr DO Statements END
  | LOCAL Var_decls SEMI Statements END
  | ID ASSIGN Expr
  | Expr SLPAR Expr SRPAR ASSIGN Expr
  | ID LPAR Exprs RPAR
  | Vars READ
  | Exprs WRITE
  | RETURN Expr
;

Vars ::= ID COMMA Vars
  | ID
;

Exprs ::= Expr COMMA Exprs
  | Expr
;

Expr ::= NIL
  | TRUE
  | FALSE
  | INT_CONST
  | FLOAT_CONST
  | STRING_CONST
  | BLPAR BRPAR COLON Type
  | ID
  | Expr SLPAR Expr SRPAR
  | ID LPAR Exprs RPAR
  | Expr PLUS Expr
  | Expr MINUS Expr
  | Expr TIMES Expr
  | Expr DIV Expr
  | Expr AND Expr
  | Expr OR Expr
  | Expr GT Expr
  | Expr GE Expr
  | Expr LT Expr
  | Expr LE Expr
  | Expr EQ Expr
  | Expr NE Expr
  | MINUS Expr
  | NOT Expr
  | SHARP Expr
;